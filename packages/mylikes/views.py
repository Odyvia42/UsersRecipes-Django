from django.shortcuts import render
from recipeblog.utils import check_likes_faves, get_paginated, get_liked_recipes


def show_my_likes_all(request):
    """
    Функция-представление для отображения списка всех рецептов, лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_all.html и контекстом,содержащим два набора рецептов:
    - набор лайкнутых рецептов с пагинацией (paged_recipes), который отображается на веб-странице;
    - набор со всеми лайкнутыми рецептами без пагинации (liked_recipes), который нужен для отображения
    общего количества лайкнутых рецептов.
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_all.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request)
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_all.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_all.html')


def show_my_likes_salads(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "салаты", лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_salads.html и контекстом,содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "салаты" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "салаты" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "салаты".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_salads.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='SL')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_salads.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_salads.html')


def show_my_likes_first_course(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "первое блюдо",
    лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_first_course.html и контекстом, содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "первое блюдо" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "первое блюдо" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "первое блюдо".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_first_course.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='FC')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_first_course.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_first_course.html')


def show_my_likes_main_course(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "второе блюдо",
    лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_main_course.html и контекстом, содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "второе блюдо" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "второе блюдо" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "второе блюдо".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_main_course.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='MC')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_main_course.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_main_course.html')


def show_my_likes_dessert(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "десерты", лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_dessert.html и контекстом, содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "десерты" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "десерты" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "десерты".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_dessert.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='DS')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_dessert.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_dessert.html')


def show_my_likes_bakery(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "выпечка", лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_bakery.html и контекстом, содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "выпечка" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "выпечка" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "выпечка".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_bakery.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='BK')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_bakery.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_bakery.html')


def show_my_likes_beverages(request):
    """
    Функция-представление для отображения списка всех рецептов в категории "напитки", лайкнутых текущим пользователем.
    Функция принимает один параметр: запрос, из которого берётся информация о текущем пользователе.
    Если пользователь вошёл на сайт, функция получает из базы данных набор рецептов, лайкнутых текущим пользователем,
    для каждого рецепта актуализирует состояние лайка/избранного (лайкнут ли пост/добавлен ли в избранное
    текущим пользователем), а также добавляет к набору рецептов пагинацию.
    Функция возвращает веб-страницу с шаблоном my_likes_beverages.html и контекстом, содержащим два набора рецептов:
    - набор лайкнутых рецептов в категории "напитки" с пагинацией (paged_recipes), который отображается
    на веб-странице;
    - набор со всеми лайкнутыми рецептами в категории "напитки" без пагинации (liked_recipes),
    который нужен для отображения общего количества лайкнутых рецептов в категории "напитки".
    Если пользователь не вошёл на сайт, функция не обращается к базе данных, а возвращает веб-страницу
    с шаблоном my_likes_beverages.html и пустым контекстом.
    """
    if request.user.is_authenticated:
        liked_recipes = get_liked_recipes(request).filter(dish_type='BV')
        check_likes_faves(request, liked_recipes)
        paged_recipes = get_paginated(request, liked_recipes)
        return render(request, 'my-likes/my_likes_beverages.html',
                      {'paged_recipes': paged_recipes,
                       'liked_recipes': liked_recipes})
    else:
        return render(request, 'my-likes/my_likes_beverages.html')
